-- Напоминание определения конкатенации двух списков (++)
-- [] ++ l2 = l2
-- (h : t) ++ l2 = h : (t ++ l2)

append' l1 l2 = foldr (\h p -> h : p) l2 l1
-- Более коротко:
append'' l1 l2 = foldr (:) l2 l1

-- β-редукция: (\x -> M) N редуцируется (переписывается) к результату
-- подстановки N вместо x в M. Это подстановка фактического параметра
-- вместо формального в тело фунции при ее вызове.

-- η-редукция: \x -> M x редуцируется к M, если x не входит в M.
-- Действительно, эти два терма ведут себя одинаково, когда выступают
-- в роли функции: (\x -> M x) N β-редуцируется к результату подстановки
-- N вместо x в M x, то есть в M N.

-- В функции append'' выше:
-- \h p -> h : p есть обозначение для \h -> (\p -> ((:) h) p).
-- (\p -> ((:) h) p) η-редуцируется к (:) h. Далее, \h -> (:) h
-- η-редуцируется к (:).

map' f l = foldr (\h p -> f h : p) [] l

-- Выразите:
-- elem через foldr
-- filter через foldr

-- foldl1 и foldr1 работают на непустых списках и используют
-- крайние элементы списка как начальное значение. Из-за этого
-- результат функции имеет тот же тип, что и элементы списка.
-- Это не обязательно верно для foldl и foldr.

maximum' l = foldl1 max l

-- Домашнее задание

-- Из предыдущего задания

-- Напишите foldl с помощью хвостовой рекурсии
-- foldl :: (a -> b -> a) -> a -> [b] -> a
-- foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn

-- Выразите iter через foldr и replicate
-- iter :: a -> (a -> a) -> Int -> a
-- iter x f n = f (f (... f x)...) (n раз, n >= 0)
-- replicate n x = [x, x, ..., x] (n элементов) (есть в Prelude)

-- Дана функция
-- collatz 1 = [1]
-- collatz n
--   | even n = n : collatz (n `div` 2)
--   | otherwise = n : collatz (3 * n + 1)

-- Напишите функцию longCollatz :: Int -> Int -> Int, такую что
-- longCollatz m n возвразает количество последовательностей Коллатца,
-- начинающихся с чисел от 1 до m и имеющих длину больше n.
-- Для этого можно сделать следущее.
-- 1. Найти список l от 1 до m.
-- 2. Найти список s последовательностей с началами в l.
-- 3. Оставить из s только списки длины > n.
-- 4. Найти длину оставшегося списка.

-- Выразите reverse через foldl

-- Новое задание

-- Объясните следующую реализацию map:
map'' f l = foldr ((:) . f) [] l

-- Изучите библиотечные функции, указанные вверху на с. 100 в книге:
-- Макеев Г.А. "Основы функционального программирования на языке Haskell".
-- См. ссылку на https://nngufall2016fp.wordpress.com/about-2/
-- Можно понять смысл функции из ее названия и типа или можно посмотреть
-- документацию по ней.

-- Напишите следующие функции, не используя рекурсии.
-- Можно использовать библиотечные функции.

-- Напишите функцию numPreds :: [a -> Bool] -> a -> Int, берущую
-- список предикатов и элемент, и находящую, сколько предикатов на
-- этом элементе возвращают True.

-- Напишите функцию findIndices :: (a -> Bool) -> [a] -> [Int],
-- находящую индексы тех элементов в списке, на которых условие
-- возвращает True.

-- Напишите функцию filterMapAnd :: [a -> Bool] -> [a] -> [a],
-- которая выбирает только те элементы из списка, на которых все
-- функции из списка функций возвращают True. Например,
-- filterMapAndMy [even, (>5), (<10)] [1..20] = [6,8] .
